from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import override

import numpy as np


class IndexMappingBase(ABC):
    @abstractmethod
    def apply(self, arr) -> np.ndarray:
        raise NotImplementedError

    @abstractmethod
    def invert(self, arr) -> np.ndarray:
        raise NotImplementedError

    def inverse_mapping(self) -> "IndexMappingBase":
        return InverseIndexMapping(self)


@dataclass(init=False, frozen=True)
class IndexMapping(IndexMappingBase):
    """gmsh tags need not be consecutive. Someone who creates the mesh may choose indices
    such that numbers make sense from a human perspective. We do not want to skip indices
    in the model.

    We want to remap tags from tag_list[i] -> i to remove any skips, where `tag_list`
    is the array of tags, say generated by gmsh.model.mesh.get_nodes()[0], we expect to see.

    Any tag list (say from a `gmsh.model.mesh.get_elements()` call) can be renumbered
    by this remapping through the `apply()` method.
    """

    original_tag_list: np.ndarray
    """The tag list, representing the tags
    expected to be managed. This object's indexing is `0:original_tag_list.size`, where
    the original index `tag_list[i]` gets mapped to `i`.
    """

    _sorted_tag_inds: np.ndarray
    """Equal to `numpy.argsort(original_tag_list)`. This stores the indices of
    original_tag_list in order of increasing values.
    """

    _sorted_tag_list: np.ndarray
    """Equal to `original_tag_list[sorted_tag_inds]`. This stores the sorted list of tags, which
    can be used by numpy.searchsorted to element-wise find the index of a tag.
    """

    def __init__(self, node_tags: np.ndarray):
        object.__setattr__(self, "original_tag_list", node_tags)

        # self.sorted_tag_inds[original_tag] == compressed_tag
        object.__setattr__(self, "_sorted_tag_inds", np.argsort(node_tags))
        object.__setattr__(self, "_sorted_tag_list", node_tags[self._sorted_tag_inds])

    @override
    def apply(self, arr) -> np.ndarray:
        """Takes an array of tags, remapping them according to the rule given by this object.

        Args:
            arr (ArrayLike): The array to remap

        Returns:
            np.ndarray: Remapped indices, in the same shape of `arr`.
        """
        return self._sorted_tag_inds[np.searchsorted(self._sorted_tag_list, arr)]

    @override
    def invert(self, arr) -> np.ndarray:
        """Inverse of apply()"""
        return self.original_tag_list[arr]

    @staticmethod
    def join(a: "IndexMapping", b: "IndexMapping") -> "JoinedIndexMapping":
        """Creates an IndexMapping that includes tags from both arguments."""
        return JoinedIndexMapping(a, b)


@dataclass(frozen=True)
class InverseIndexMapping(IndexMappingBase):
    """Takes an index mapping and swaps the apply and invert functions."""

    original_mapping: IndexMappingBase

    @override
    def apply(self, arr) -> np.ndarray:
        return self.original_mapping.invert(arr)

    @override
    def invert(self, arr) -> np.ndarray:
        return self.original_mapping.apply(arr)

    @override
    def inverse_mapping(self) -> "IndexMappingBase":
        return self.original_mapping


@dataclass(frozen=True)
class ComposedIndexMapping(IndexMappingBase):
    """Couples index mappings by applying one after another."""

    left_map: IndexMappingBase
    right_map: IndexMappingBase

    @override
    def apply(self, arr) -> np.ndarray:
        return self.left_map.apply(self.right_map.apply(arr))

    @override
    def invert(self, arr) -> np.ndarray:
        return self.right_map.invert(self.left_map.invert(arr))

    @override
    def inverse_mapping(self) -> "IndexMappingBase":
        return ComposedIndexMapping(
            self.right_map.inverse_mapping(), self.left_map.inverse_mapping()
        )


@dataclass(init=False, frozen=True)
class JoinedIndexMapping(IndexMapping):
    """When taking the union of two models, we want to be able to map indices from the
    original models into the new model. This handles that.

    Indices may be shared between the two. In such a case, we expect those to be mapped
    to the same value.
    """

    original_left_remapping: IndexMapping
    original_right_remapping: IndexMapping

    left_to_joined: IndexMapping
    right_to_joined: IndexMapping

    def __init__(self, left: IndexMapping, right: IndexMapping):
        super().__init__(
            np.unique_values(
                np.concatenate([left.original_tag_list, right.original_tag_list])
            )
        )
        object.__setattr__(self, "original_left_remapping", left)
        object.__setattr__(self, "original_right_remapping", right)
        object.__setattr__(self, "left_to_joined", ComposedIndexMapping(self,left.inverse_mapping()))
        object.__setattr__(self, "right_to_joined", ComposedIndexMapping(self,right.inverse_mapping()))
