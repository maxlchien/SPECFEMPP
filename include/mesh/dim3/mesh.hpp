#pragma once

#include "adjacency_graph/adjacency_graph.hpp"
#include "boundaries/boundaries.hpp"
#include "control_nodes/control_nodes.hpp"
#include "enumerations/interface.hpp"
#include "materials/materials.hpp"
#include "tags/tags.hpp"

namespace specfem::mesh {

template <specfem::dimension::type DimensionTag> struct mesh;

/**
 * @brief 3D mesh data container for MESHFEM3D-generated spectral element meshes
 *
 * This template specialization manages 3D mesh data structures generated by
 * MESHFEM3D. The mesh structure serves as the primary data interface between
 * MESHFEM3D database files and the SPECFEM++ computational engine.
 *
 * This design follows the SPECFEM3D workflow where MESHFEM3D generates binary
 * database files containing pre-computed mesh information, which are then read
 * by the main solver for efficient spectral element computations.
 *
 * @tparam specfem::dimension::type::dim3 Template specialization for 3D spatial
 * dimension
 *
 * @see specfem::io::meshfem3d::read_3d_mesh
 * @see specfem::mesh::control_nodes
 * @see specfem::mesh::materials
 * @see specfem::mesh::boundaries
 *
 * @code
 * // Example: Reading a MESHFEM3D database
 * std::string param_file = "MESH/parameters.bin";
 * std::string database_file = "MESH/database.bin";
 *
 * // Read mesh from MESHFEM3D binary files
 * auto mesh = specfem::io::meshfem3d::read_3d_mesh(param_file, database_file);
 *
 * // Access mesh components
 * int num_nodes = mesh.control_nodes.ngnod;
 * int num_materials = mesh.materials.number_of_materials;
 * int num_absorbing_faces = mesh.absorbing_boundaries.nfaces;
 *
 * // Use in spectral element computation
 * // (mesh data is typically passed to solver initialization)
 * @endcode
 */
template <> struct mesh<specfem::dimension::type::dim3> {

  constexpr static auto dimension_tag =
      specfem::dimension::type::dim3; ///< Dimension tag

  /**
   * @brief Number of spectral elements in the mesh
   *
   */
  int nspec;

  specfem::mesh_entity::element<dimension_tag> element_grid;

  /**
   * @brief Control node geometric data container
   *
   * Stores coordinate information and connectivity data for control nodes
   * that define the geometric structure of spectral elements. These nodes
   * are read from MESHFEM3D database files and represent the high-order
   * geometric mapping points used in spectral element discretization.
   *
   * @see specfem::mesh::control_nodes
   */
  specfem::mesh::control_nodes<dimension_tag> control_nodes;

  /**
   * @brief Material properties database
   *
   * Contains physical material properties (elastic, acoustic, poroelastic)
   * mapped to different regions of the mesh. Materials are organized by
   * medium type and property characteristics, enabling efficient material
   * property lookup during spectral element computations.
   *
   * @see specfem::mesh::materials
   */
  specfem::mesh::materials<dimension_tag> materials;

  /**
   * @brief Absorbing boundary condition specifications
   *
   * Stores information about mesh faces designated as absorbing boundaries
   * for implementing Stacey absorbing boundary conditions. These boundaries
   * prevent spurious wave reflections at domain edges by absorbing outgoing
   * seismic waves.
   *
   * @see specfem::mesh::boundaries
   */
  specfem::mesh::boundaries<dimension_tag> boundaries;

  /**
   * @brief Element adjacency graph
   *
   * Represents the connectivity relationships between spectral elements in
   * the mesh.
   *
   * @see specfem::mesh::adjacency_graph
   */
  specfem::mesh::adjacency_graph<dimension_tag> adjacency_graph;

  /** @brief Tags associated with each spectral element
   *
   * Stores the tags for each spectral element, which specify medium type,
   * property type, and boundary conditions.
   */
  specfem::mesh::tags<dimension_tag> tags;

  /**
   * @brief Setup coupled interfaces in the mesh
   *
   * Coupled interfaces are essential for multi-domain simulations where
   * different materials or physical models interact at shared boundaries.
   *
   * @note This function should be called after the mesh has been fully
   * initialized and all components (control nodes, materials, boundaries)
   * have been populated from MESHFEM3D database files.
   */
  void setup_coupled_interfaces();

  /**
   * @brief Default constructor
   *
   * Creates an empty mesh structure with default-initialized components.
   * This constructor is typically used internally by IO routines which
   * populate the mesh data by reading from MESHFEM3D database files.
   *
   * @code
   * // Internal usage in IO routines
   * specfem::mesh::mesh<specfem::dimension::type::dim3> mesh;
   * mesh.control_nodes = read_control_nodes(stream);
   * mesh.materials = read_materials(stream);
   * mesh.absorbing_boundaries = read_absorbing_boundaries(stream);
   * @endcode
   */
  mesh() = default;

  /**
   * @brief Default destructor
   *
   * Automatically destroys all mesh components. Memory management is handled
   * by the individual component destructors (ControlNodes, Materials,
   * AbsorbingBoundaries).
   */
  ~mesh() = default;
};

} // namespace specfem::mesh
