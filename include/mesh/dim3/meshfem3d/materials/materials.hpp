#pragma once

#include "enumerations/interface.hpp"
#include "medium/material.hpp"
#include "specfem/macros.hpp"
#include <Kokkos_Core.hpp>
#include <vector>

namespace specfem::mesh::meshfem3d {

template <specfem::dimension::type Dimension> struct Materials;

/**
 * @brief 3D specialization for MESHFEM3D material database management
 *
 * This specialized implementation manages material properties for 3D
 * spectral element simulations generated by MESHFEM3D. It provides:
 *
 * - Storage for materials read from MESHFEM3D database files
 * - Type-safe material containers organized by medium and property types
 * - Mapping between spectral elements and their material specifications
 * - Template metaprogramming for compile-time material type dispatch
 *
 * This ensures comprehensive material support while maintaining type safety
 * and enabling compile-time optimizations in the spectral element framework.
 *
 * @see specfem::medium::material
 * @see FOR_EACH_IN_PRODUCT
 *
 * @code
 * // Create materials database for 1000 elements with 5 unique materials
 * spectral::mesh::meshfem3d::Materials<specfem::dimension::type::dim3>
 *     materials(1000, 5);
 *
 * // Add an isotropic elastic material from MESHFEM3D database
 * specfem::medium::material<specfem::element::medium_tag::elastic,
 *                          specfem::element::property_tag::isotropic>
 * elastic_mat; materials.add_material(elastic_mat, database_index);
 *
 * // Retrieve material for element during simulation
 * auto material = materials.get_material<specfem::element::medium_tag::elastic,
 *                                       specfem::element::property_tag::isotropic>(elem_id);
 * @endcode
 */
template <> struct Materials<specfem::dimension::type::dim3> {
  /**
   * @brief Dimension tag for compile-time type identification
   *
   * Fixed to dim3 for this specialization, used for template metaprogramming
   * and ensuring compatibility with the SPECFEM++ dimension system.
   */
  static constexpr auto dimension_tag = specfem::dimension::type::dim3;

  /**
   * @brief Material specification linking elements to material database entries
   *
   * Associates spectral elements with their corresponding material types and
   * database indices from MESHFEM3D material files. This structure provides
   * the mapping between mesh topology and material properties.
   *
   * Used internally to maintain the association between:
   * - Element indices in the mesh
   * - Material types (medium + property combinations)
   * - Original database indices from MESHFEM3D input files
   * - Local indices within type-specific material containers
   */
  struct material_specification {
    /** @brief Physical medium type (acoustic, elastic, etc.) */
    specfem::element::medium_tag type;

    /** @brief Material property type (isotropic, anisotropic) */
    specfem::element::property_tag property;

    /** @brief Local index within the type-specific material container */
    int index;

    /** @brief Original database index from MESHFEM3D material files */
    int database_index;

    /** @brief Default constructor initializing with default values */
    material_specification() = default;

    /**
     * @brief Construct material specification from components
     *
     * @param type Physical medium type for wave equation selection
     * @param property Material property type for constitutive relations
     * @param index Local material index within container
     * @param database_index Original MESHFEM3D database index
     */
    material_specification(specfem::element::medium_tag type,
                           specfem::element::property_tag property, int index,
                           int database_index)
        : type(type), property(property), index(index),
          database_index(database_index) {};
  };

  /**
   * @brief Template container for materials of specific type and property
   *
   * Stores material objects of a specific medium/property combination with
   * count tracking for efficient memory management. Each container holds
   * materials of exactly one type (e.g., all elastic isotropic materials).
   *
   * This design enables:
   * - Type-safe material storage and retrieval
   * - Efficient memory layout for materials of the same type
   * - Compile-time optimization based on material properties
   * - Integration with SPECFEM++ template metaprogramming system
   *
   * @tparam type Medium type (acoustic, elastic)
   * @tparam property Property type (isotropic, anisotropic)
   */
  template <specfem::element::medium_tag type,
            specfem::element::property_tag property>
  struct material {
    /** @brief Number of materials stored in this container */
    int n_materials;

    /** @brief Storage for material objects of this type/property combination */
    std::vector<specfem::medium::material<type, property> > element_materials;

    /** @brief Default constructor creating empty container */
    material() : n_materials(0) {}

    /**
     * @brief Construct container from existing material vector
     *
     * @param n_materials Number of materials to store
     * @param l_material Vector of materials to initialize container with
     */
    material(const int n_materials,
             const std::vector<specfem::medium::material<type, property> >
                 &l_material);
  };

  /** @name Core Data Members */
  /** @{ */

  /** @brief Total number of materials across all type containers */
  int n_materials;

  int nspec; ///< Total number of spectral elements in the mesh

  /**
   * @brief Mapping from element index to material specification
   *
   * For each spectral element in the mesh, stores the material specification
   * that identifies which material container and index to use for retrieving
   * the element's material properties. This provides the link between mesh
   * topology and material database entries.
   */
  std::vector<material_specification> material_index_mapping;

private:
  /** @} */

  /** @name Auto-Generated Material Containers */
  /** @{ */

  /**
   * @brief Template metaprogramming expansion for material containers
   *
   * The FOR_EACH_IN_PRODUCT macro automatically generates material containers
   * for all valid combinations of dimension, medium, and property types.
   *
   * For 3D MESHFEM3D, this expands to create containers for:
   * - material<acoustic, isotropic>: Acoustic isotropic materials
   * - material<acoustic, anisotropic>: Acoustic anisotropic materials
   * - material<elastic, isotropic>: Elastic isotropic materials
   * - material<elastic, anisotropic>: Elastic anisotropic materials
   *
   * The DECLARE macro generates member variable declarations with names
   * derived from the template parameters, enabling compile-time dispatch
   * in the get_material() and get_container() methods.
   *
   * This approach ensures:
   * - Complete coverage of all material type combinations
   * - Type safety at compile time
   * - Efficient storage organization by material type
   * - Integration with SPECFEM++ template metaprogramming patterns
   */
  FOR_EACH_IN_PRODUCT((DIMENSION_TAG(DIM3), MEDIUM_TAG(ACOUSTIC, ELASTIC),
                       PROPERTY_TAG(ISOTROPIC, ANISOTROPIC)),
                      DECLARE(((specfem::mesh::meshfem3d::Materials,
                                (_DIMENSION_TAG_), ::material,
                                (_MEDIUM_TAG_, _PROPERTY_TAG_)),
                               material)))

  /** @} */
public:
  /** @name Constructors */
  /** @{ */

  /**
   * @brief Default constructor creating empty materials database
   *
   * Creates an uninitialized materials collection with no elements or
   * materials. Suitable for delayed initialization or when material
   * data will be populated later through other means.
   */
  Materials() : n_materials(0), nspec(0) {}

  /** @} */

  /** @name Material Access Interface */
  /** @{ */

  /**
   * @brief Retrieve material object for a specific element with type safety
   *
   * Returns the material object associated with the given element index using
   * compile-time template parameters for the specified medium and property
   * types.
   *
   * @tparam MediumTag Medium type (acoustic, elastic)
   * @tparam PropertyTag Property type (isotropic, anisotropic)
   * @param index Element index to retrieve material for
   * @return Material object with specified medium and property types
   *
   * @code
   * // Retrieve elastic isotropic material for element 42
   * auto elastic_material = materials.get_material<
   *     specfem::element::medium_tag::elastic,
   *     specfem::element::property_tag::isotropic>(42);
   *
   * // Access material properties
   * auto density = elastic_material.get_density();
   * auto vp = elastic_material.get_p_velocity();
   * auto vs = elastic_material.get_s_velocity();
   *
   * // Use in wave equation computations
   * compute_elastic_forces(elastic_material, element_coords);
   * @endcode
   */
  template <specfem::element::medium_tag MediumTag,
            specfem::element::property_tag PropertyTag>
  specfem::medium::material<MediumTag, PropertyTag>
  get_material(const int index) const {
#ifndef NDEBUG
    if (index < 0 || index >= this->nspec) {
      KOKKOS_ABORT_WITH_LOCATION("Element index out of range in get_material");
    }
#endif
    const auto &material_specification = this->material_index_mapping[index];

#ifndef NDEBUG
    if (material_specification.type != MediumTag ||
        material_specification.property != PropertyTag) {
      KOKKOS_ABORT_WITH_LOCATION("Material type mismatch in get_material");
    }
#endif

    FOR_EACH_IN_PRODUCT(
        (DIMENSION_TAG(DIM3), MEDIUM_TAG(ACOUSTIC, ELASTIC),
         PROPERTY_TAG(ISOTROPIC, ANISOTROPIC)),
        CAPTURE(material) {
          if constexpr (MediumTag == _medium_tag_ &&
                        PropertyTag == _property_tag_) {
            return _material_.element_materials[material_specification.index];
          }
        })

    Kokkos::abort("Invalid material type detected in material specification");

    return {};
  }

  /**
   * @brief Get reference to material container for specific medium and property
   * types
   *
   * Returns a reference to the internal container storing materials of the
   * specified type combination for direct access by material management
   * functions.
   *
   * @tparam MediumTag Medium type (acoustic, elastic)
   * @tparam PropertyTag Property type (isotropic, anisotropic)
   * @return Reference to the material container for specified types
   *
   * @code
   * // Get container for elastic isotropic materials
   * auto& elastic_container = materials.get_container<
   *     specfem::element::medium_tag::elastic,
   *     specfem::element::property_tag::isotropic>();
   *
   * // Access container properties
   * int num_elastic_materials = elastic_container.n_materials;
   * auto& material_vector = elastic_container.element_materials;
   *
   * // Direct manipulation (use with caution)
   * elastic_container.element_materials.reserve(expected_count);
   * @endcode
   */
  template <specfem::element::medium_tag MediumTag,
            specfem::element::property_tag PropertyTag>
  specfem::mesh::meshfem3d::Materials<dimension_tag>::material<MediumTag,
                                                               PropertyTag> &
  get_container() {

    FOR_EACH_IN_PRODUCT((DIMENSION_TAG(DIM3), MEDIUM_TAG(ACOUSTIC, ELASTIC),
                         PROPERTY_TAG(ISOTROPIC, ANISOTROPIC)),
                        CAPTURE(material) {
                          if constexpr (_medium_tag_ == MediumTag &&
                                        _property_tag_ == PropertyTag) {
                            return _material_;
                          }
                        })

    Kokkos::abort("Invalid material type detected in material specification");
  }

  /**
   * @brief Add a new material to the database
   *
   * Adds a material to the appropriate container based on its type, updates
   * counts, and creates mapping to the original MESHFEM3D database index.
   *
   * @tparam MediumTag Medium type (acoustic, elastic)
   * @tparam PropertyTag Property type (isotropic, anisotropic)
   * @param new_material Material object to add
   * @param database_index Original MESHFEM3D database index
   * @return Local index of the added material within its container
   *
   * @code
   * // Add elastic isotropic material from MESHFEM3D database
   * specfem::medium::material<specfem::element::medium_tag::elastic,
   *                          specfem::element::property_tag::isotropic> mat;
   * const auto index = materials.add_material(mat);
   * @endcode
   */
  template <specfem::element::medium_tag MediumTag,
            specfem::element::property_tag PropertyTag>
  int add_material(
      const specfem::medium::material<MediumTag, PropertyTag> &new_material) {
    this->n_materials += 1;
    auto &material_container = this->get_container<MediumTag, PropertyTag>();
    material_container.element_materials.push_back(new_material);
    material_container.n_materials += 1;

    return material_container.n_materials - 1;
  }

  /**
   * @brief Get the medium and property types for a given element index
   *
   * Returns a tuple containing the medium and property tags associated with
   * the material specification for the specified element index.
   *
   * @param index Element index to query
   * @return Tuple of (medium_tag, property_tag) for the element's material
   *
   * @code
   * // Get material type for element 42
   * auto [medium, property] = materials.get_material_type(42);
   *
   * // Use in conditional logic
   * if (medium == specfem::element::medium_tag::elastic &&
   *     property == specfem::element::property_tag::isotropic) {
   *     // Handle elastic isotropic case
   * }
   * @endcode
   */
  std::tuple<specfem::element::medium_tag, specfem::element::property_tag>
  get_material_type(const int index) const {
#ifndef NDEBUG
    if (index < 0 || index >= this->nspec) {
      KOKKOS_ABORT_WITH_LOCATION(
          "Element index out of range in get_material_type");
    }
#endif
    const auto &material_specification = this->material_index_mapping[index];
    return std::make_tuple(material_specification.type,
                           material_specification.property);
  }

  /** @} */ // End Material Access Interface
}; // End Materials<dim3> specialization
} // namespace specfem::mesh::meshfem3d
