#pragma once

#include "enumerations/interface.hpp"
#include <boost/graph/adjacency_list.hpp>

namespace specfem::mesh::meshfem3d {

/**
 * @brief Template structure for element adjacency graph management in MESHFEM3D
 *
 * Generic template declaration for adjacency graph structures that manage
 * element connectivity information from MESHFEM3D-generated mesh databases.
 * The adjacency graph encodes neighbor relationships and connection properties
 * between spectral elements.
 *
 * @tparam Dimension Spatial dimension type tag for template specialization
 */
template <specfem::dimension::type Dimension> struct adjacency_graph;

/**
 * @brief 3D adjacency graph for MESHFEM3D spectral element connectivity
 *
 * This template specialization provides a graph-based representation of element
 * connectivity in 3D spectral element meshes generated by MESHFEM3D. The class
 * uses the Boost Graph Library to efficiently manage and query adjacency
 * relationships between spectral elements, including connection types and
 * geometric orientations.
 *
 * The adjacency graph encodes:
 * - **Element neighbors**: Which elements share faces, edges, or corners
 * - **Connection types**: Conforming vs. non-conforming interfaces
 * - **Geometric orientation**: Face/edge alignment between adjacent elements
 *
 * This graph structure is essential for:
 * - Flux calculations across element interfaces
 * - Discontinuous Galerkin coupling
 * - Boundary condition enforcement
 *
 * @tparam specfem::dimension::type::dim3 Template specialization for 3D meshes
 *
 * @see specfem::mesh::adjacency (CSR-based adjacency for solver)
 * @see specfem::connections::type
 * @see specfem::mesh_entity::dim3::type
 *
 * @code
 * // Example: Building adjacency graph from MESHFEM3D data
 * specfem::mesh::meshfem3d::adjacency_graph<specfem::dimension::type::dim3>
 *     adj_graph(nspec);
 *
 * // Add element connections with properties
 * auto& graph = adj_graph.graph();
 * boost::add_edge(elem1_id, elem2_id,
 *     EdgeProperties(specfem::connections::type::strongly_conforming,
 *                   specfem::mesh_entity::dim3::type::right), graph);
 *
 * // Query adjacency for spectral element computations
 * for (auto [edge_iter, edge_end] = boost::edges(graph);
 *      edge_iter != edge_end; ++edge_iter) {
 *     auto edge_props = graph[*edge_iter];
 *     // Process interface based on connection type and orientation
 * }
 * @endcode
 *
 * @note This class is primarily used during mesh preprocessing and setup.
 *       Runtime computations typically use the more efficient CSR format
 *       in specfem::mesh::adjacency.
 */
template <> struct adjacency_graph<specfem::dimension::type::dim3> {
public:
  /**
   * @brief Edge properties for element interface characterization
   *
   * Stores the geometric and connectivity properties of interfaces between
   * adjacent spectral elements. Each edge in the adjacency graph represents
   * a shared interface (face, edge, or corner) between two elements, with
   * associated metadata describing the connection characteristics.
   *
   * @code
   * // Example: Creating edge properties for a conforming face interface
   * EdgeProperties face_props(
   *     specfem::connections::type::strongly_conforming,
   *     specfem::mesh_entity::dim3::type::right
   * );
   *
   * // Add to graph edge
   * boost::add_edge(elem1, elem2, face_props, graph);
   * @endcode
   */
  struct EdgeProperties {
    /**
     * @brief Type of connection between adjacent elements
     *
     * Specifies the conformity and coupling characteristics of the interface:
     * - **strongly_conforming**: Nodes match exactly (continuous coupling)
     * - **weakly_conforming**: Nodes match but allows discontinuous coupling
     * - **nonconforming**: No matching nodes, geometric adjacency only
     *
     * @see specfem::connections::type
     */
    specfem::connections::type connection;

    /**
     * @brief Geometric orientation of the shared interface
     *
     * Identifies which face, edge, or corner of the hexahedral element
     * participates in the adjacency relationship. This information is
     * crucial for:
     * - Flux computation across interfaces
     * - Proper geometric transformation setup
     * - Boundary condition application
     *
     * @see specfem::mesh_entity::dim3::type
     */
    specfem::mesh_entity::dim3::type orientation;

    /**
     * @brief Default constructor
     *
     * Creates edge properties with uninitialized values. This constructor
     * is used internally by Boost Graph Library during graph operations.
     */
    EdgeProperties() = default;

    /**
     * @brief Constructor with connection and orientation specification
     *
     * Creates edge properties for a specific interface between two elements,
     * encoding both the connection type and the geometric orientation.
     *
     * @param conn Type of connection (conforming/non-conforming)
     * @param orient Geometric orientation of the shared interface
     *
     * @code
     * // Create properties for a strongly conforming face interface
     * EdgeProperties props(
     *     specfem::connections::type::strongly_conforming,
     *     specfem::mesh_entity::dim3::type::right
     * );
     * @endcode
     */
    EdgeProperties(const specfem::connections::type conn,
                   const specfem::mesh_entity::dim3::type orient)
        : connection(conn), orientation(orient) {}
  };

private:
  /**
   * @brief Boost Graph Library adjacency list type definition
   *
   * Uses directed adjacency list with:
   * - **vecS**: Vector-based vertex storage for O(1) access by element ID
   * - **vecS**: Vector-based edge storage for efficient iteration
   * - **directedS**: Directed edges to encode interface directionality
   * - **boost::no_property**: No vertex properties needed (element ID implicit)
   * - **EdgeProperties**: Rich edge metadata for interface characterization
   */
  using Graph =
      boost::adjacency_list<boost::vecS, boost::vecS, boost::directedS,
                            boost::no_property, EdgeProperties>;

  /**
   * @brief Internal Boost Graph Library graph instance
   *
   * Stores the complete adjacency graph with vertices representing spectral
   * elements and edges representing interfaces with their properties.
   */
  Graph graph_;

public:
  /**
   * @brief Default constructor
   *
   * Creates an empty adjacency graph with no vertices or edges.
   * Elements and connections must be added explicitly after construction.
   *
   * @code
   * specfem::mesh::meshfem3d::adjacency_graph<specfem::dimension::type::dim3>
   *     empty_graph;
   * // Graph must be populated with add_vertex/add_edge operations
   * @endcode
   */
  adjacency_graph() = default;

  /**
   * @brief Constructor with pre-allocated vertex capacity
   *
   * Creates an adjacency graph with the specified number of vertices
   * (spectral elements) pre-allocated. This constructor is efficient when
   * the number of elements is known in advance from MESHFEM3D data.
   *
   * @param nspec Number of spectral elements in the mesh
   *
   * @code
   * // Create graph for mesh with 1000 spectral elements
   * specfem::mesh::meshfem3d::adjacency_graph<specfem::dimension::type::dim3>
   *     graph(1000);
   * // Vertices 0-999 are pre-allocated and ready for edge addition
   * @endcode
   */
  adjacency_graph(const int nspec) : graph_(nspec) {}

  /**
   * @brief Mutable access to the underlying Boost Graph
   *
   * Provides direct access to the Boost Graph Library adjacency list for
   * advanced graph operations, including vertex/edge addition, modification,
   * and complex queries.
   *
   * @return Graph& Reference to the internal boost::adjacency_list
   *
   * @code
   * auto& graph = adj_graph.graph();
   *
   * // Add edge with properties
   * boost::add_edge(0, 1, EdgeProperties(
   *     specfem::connections::type::strongly_conforming,
   *     specfem::mesh_entity::dim3::type::right), graph);
   *
   * // Query neighbors
   * auto [adj_iter, adj_end] = boost::adjacent_vertices(0, graph);
   * @endcode
   */
  Graph &graph() { return graph_; }

  /**
   * @brief Immutable access to the underlying Boost Graph
   *
   * Provides read-only access to the Boost Graph Library adjacency list for
   * queries and analysis operations without modification capabilities.
   *
   * @return const Graph& Const reference to the internal boost::adjacency_list
   *
   * @code
   * const auto& graph = adj_graph.graph();
   *
   * // Query graph properties
   * size_t num_elements = boost::num_vertices(graph);
   * size_t num_connections = boost::num_edges(graph);
   *
   * // Iterate over all edges
   * for (auto [edge_iter, edge_end] = boost::edges(graph);
   *      edge_iter != edge_end; ++edge_iter) {
   *     auto props = graph[*edge_iter];
   *     // Process edge properties
   * }
   * @endcode
   */
  const Graph &graph() const { return graph_; }

  /**
   * @brief Check if the adjacency graph is empty
   *
   * Determines whether the graph contains any spectral elements (vertices).
   * An empty graph has no vertices and therefore no edges.
   *
   * @return true if the graph contains no vertices, false otherwise
   *
   * @code
   * if (adj_graph.empty()) {
   *     // Graph needs to be populated from MESHFEM3D data
   *     load_adjacency_from_meshfem3d(adj_graph);
   * }
   * @endcode
   */
  bool empty() const { return boost::num_vertices(graph_) == 0; }

  /**
   * @brief Verify graph symmetry for undirected adjacency relationships
   *
   * Validates that the adjacency graph correctly represents undirected
   * element connections by ensuring that for every edge (u,v) there exists
   * a corresponding edge (v,u) with compatible properties. This is essential
   * for spectral element methods where interface coupling is symmetric.
   *
   * @throws std::runtime_error if asymmetric adjacency is detected
   *
   * @code
   * // Validate graph consistency after construction
   * try {
   *     adj_graph.assert_symmetry();
   *     std::cout << "Graph adjacency is symmetric" << std::endl;
   * } catch (const std::runtime_error& e) {
   *     std::cerr << "Adjacency error: " << e.what() << std::endl;
   * }
   * @endcode
   */
  void assert_symmetry() const;
};

} // namespace specfem::mesh::meshfem3d
