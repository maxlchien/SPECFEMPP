#pragma once

#include "medium/impl/point_container.hpp"
#include <Kokkos_Core.hpp>

namespace specfem::point::impl::properties {

/**
 * @defgroup specfem_point_properties_elastic_isotropic Elastic
 * Isotropic Properties
 * @{
 */

/**
 * @ingroup specfem_point_properties_elastic_isotropic
 * @brief Data container to hold properties of elastic media at a quadrature
 * point
 *
 * @tparam UseSIMD Boolean indicating whether to use SIMD intrinsics
 *
 * <b> Accessor functions generated by the </b> \c POINT_CONTAINER \c MACRO
 *
 * - Get Kappa @f$ \kappa @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type kappa() const @endcode
 *
 * - Get shear modulus @f$ \mu @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type mu() const @endcode
 *
 * - Get density @f$ \rho @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type rho() const @endcode
 *
 * <b> Additional accessor functions </b>
 *
 * - Get Lame's parameter @f$ \lambda + 2\mu @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type lambdaplus2mu() const
 * @endcode
 *
 * - Compute the product of density and P-wave velocity squared, i.e., @f$ \rho
 *   v_p^2 = \rho (\lambda + 2\mu) @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type rho_vp() const @endcode
 *
 * - Compute the product of density and S-wave velocity squared, i.e., @f$ \rho
 *   v_s^2 = \rho \mu @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type rho_vs() const @endcode
 *
 * - Get Lame's first parameter @f$ \lambda @f$ from @f$ \lambda + 2\mu @f$ and
 *   @f$ \mu @f$
 *   @code KOKKOS_INLINE_FUNCTION const value_type lambda() const @endcode
 */
template <specfem::dimension::type DimensionTag,
          specfem::element::medium_tag MediumTag, bool UseSIMD>
struct data_container<
    DimensionTag, MediumTag, specfem::element::property_tag::isotropic, UseSIMD,
    std::enable_if_t<specfem::element::is_elastic<MediumTag>::value> >
/// @cond
    : public PropertyAccessor<DimensionTag, MediumTag,
                              specfem::element::property_tag::isotropic,
                              UseSIMD>
/// @endcond
{
private:
  using base_type = PropertyAccessor<DimensionTag, MediumTag,
                                     specfem::element::property_tag::isotropic,
                                     UseSIMD>; ///< Base type of the
                                               ///< point properties
public:
  using value_type = typename base_type::value_type; ///< Type of the properties

  using simd = typename base_type::simd;

  POINT_CONTAINER(kappa, mu, rho)

  KOKKOS_INLINE_FUNCTION const value_type lambdaplus2mu() const {
    return kappa() + (static_cast<type_real>(4.0 / 3.0)) * mu();
  }

  KOKKOS_INLINE_FUNCTION const value_type rho_vp() const {
    // we could compute this as sqrt((lambda + 2*mu) * rho())
    // but we prefer to use the definition
    // rho_vp = sqrt((lambda + 2*mu)/rho)) * rho
    // for better precision
    return Kokkos::sqrt(lambdaplus2mu() / rho()) * rho();
  }

  KOKKOS_INLINE_FUNCTION const value_type rho_vs() const {
    return Kokkos::sqrt(rho() * mu());
  }

  KOKKOS_INLINE_FUNCTION const value_type lambda() const {
    return lambdaplus2mu() - (static_cast<type_real>(2.0)) * mu();
  }
};
///@} end of group specfem_point_properties_elastic_isotropic

} // namespace specfem::point::impl::properties